{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TypeOperators #-}

module Customer.IO.Track (
    -- * Client
    CustomerIOClient (..),
    createTrackClient,
    identifyUser,

    -- * Types
    CustomerIOAuth (..),
    IdentifyRequest (..),

    -- * Errors
    CustomerIOError (..),
) where

import Control.Monad.Except (ExceptT, runExceptT)
import Control.Monad.IO.Class (liftIO)
import Data.Aeson (ToJSON)
import Data.Aeson qualified as Aeson
import Data.Map (Map)
import Data.Maybe (fromMaybe)
import Data.Text (Text)
import Data.Text.Encoding qualified as T
import GHC.Generics (Generic)
import Network.HTTP.Client (newManager)
import Network.HTTP.Client.TLS (tlsManagerSettings)
import Servant.API
import Servant.Client


-- | Authentication credentials for Customer.io
data CustomerIOAuth = CustomerIOAuth
    { siteId :: Text
    -- ^ Your Customer.io Site ID
    , apiKey :: Text
    -- ^ Your Customer.io API Key
    }
    deriving (Show)


-- | Request body for identifying a user
newtype IdentifyRequest = IdentifyRequest
    { attributes :: Map Text Aeson.Value
    -- ^ User attributes
    }
    deriving (Show, Generic)


instance ToJSON IdentifyRequest where
    toJSON (IdentifyRequest attrs) = Aeson.Object (Aeson.fromMap attrs)


-- | Customer.io API errors
newtype CustomerIOError = CustomerIOError ClientError
    deriving (Show)


-- | The identify endpoint - PUT /api/v1/customers/{identifier}
type IdentifyAPI =
    "api"
        :> "v1"
        :> "customers"
        :> Capture "identifier" Text
        :> BasicAuth "customer-io" ()
        :> ReqBody '[JSON] IdentifyRequest
        :> Put '[JSON] NoContent


-- | Simple Customer.io client
data CustomerIOClient = CustomerIOClient
    { clientAuth :: CustomerIOAuth
    , clientEnv :: ClientEnv
    }


-- | Create a Customer.io client with hardcoded track.customer.io URL
createTrackClient :: CustomerIOAuth -> IO CustomerIOClient
createTrackClient auth = do
    manager <- newManager tlsManagerSettings
    let baseUrl = fromMaybe (error "Invalid hardcoded URL") $ parseBaseUrl "https://track.customer.io"
        env = mkClientEnv manager baseUrl
    pure $ CustomerIOClient auth env


-- | Identify a user by their identifier with attributes
identifyUser :: CustomerIOClient -> Text -> Map Text Aeson.Value -> IO (Either CustomerIOError ())
identifyUser client identifier attrs = do
    result <- runExceptT $ do
        let request = IdentifyRequest attrs
            basicAuth =
                BasicAuthData
                    (T.encodeUtf8 $ siteId $ clientAuth client)
                    (T.encodeUtf8 $ apiKey $ clientAuth client)
        liftIO $ runClientM (identifyClient identifier basicAuth request) (clientEnv client)
    case result of
        Left err -> pure . Left $ CustomerIOError err
        Right _ -> pure $ Right ()


-- | Internal client function generated by servant-client
identifyClient :: Text -> BasicAuthData -> IdentifyRequest -> ClientM NoContent
identifyClient = client (Proxy :: Proxy IdentifyAPI)
